package nsl.sam.core.config

import nsl.sam.annotation.AnnotationMetadataResolver
import nsl.sam.configurer.ConfigurersFactories
import nsl.sam.instrumentation.InstrumentedClassProvider
import nsl.sam.logger.logger
import nsl.sam.core.annotation.*
import nsl.sam.core.config.ordering.OrderingHelper
import nsl.sam.core.config.ordering.ReservedNumbersFinder
import nsl.sam.core.config.sequencer.SimpleVolatileSequencer
import org.springframework.beans.factory.BeanFactory
import org.springframework.beans.factory.BeanFactoryAware
import org.springframework.beans.factory.ListableBeanFactory
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.support.BeanDefinitionRegistry
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar
import org.springframework.core.type.AnnotationMetadata
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import kotlin.reflect.full.cast

class DynamicImportBeanDefinitionRegistrar: ImportBeanDefinitionRegistrar, BeanFactoryAware {

    companion object {
        val log by logger()
    }

    lateinit var listableBeanFactory: ListableBeanFactory

    private val orderingHelper = OrderingHelper.getSingleton()

    override fun setBeanFactory(beanFactory: BeanFactory) {
        this.listableBeanFactory = ListableBeanFactory::class.cast(beanFactory)
    }

    @Synchronized
    override fun registerBeanDefinitions(importingClassMetadata: AnnotationMetadata, registry: BeanDefinitionRegistry) {

        //val annotationMetadataResolver = AnnotationMetadataResolver(
        //        importingClassMetadata, EnableSimpleAuthenticationMethods::class
        //)
        //val value = annotationMetadataResolver.getAttributeValue("debug", Boolean::class)

        val annotationAttributes = getAnnotationAttributes(importingClassMetadata)
        log.debug("annotation attributes for ${importingClassMetadata.className}: $annotationAttributes")

//        if(annotationAttributes.methods.contains(AuthenticationMethod.SIMPLE_NO_METHOD)) {
//            log.debug("Skipping authentication configuration because one of declared methods is " +
//                    "${AuthenticationMethod.SIMPLE_NO_METHOD.name}")
//            return
//        }

        /*
         * due to auto-ordering mechanism, I need to know all reserved order number,
         * so that they will not be used by auto-ordering
         */
        if(!orderingHelper.isAlreadyInitializedWithRestrictedList) {
            log.debug("Looking for and remembering all order numbers used explicitly with @EnableSimpleAuthenticationMethods annotation.")
            orderingHelper.initializeWithRestrictedList(findReservedOrderNumbers())
        }


        /*
         * generating brand new class which extends WebSecurityConfigurerAdapter
         */
        val dynamicConfigurerClass = InstrumentedClassProvider.generateRenamedClass(
                InstrumentedWebSecurityConfigurerTemplate::class.java,
                InstrumentedWebSecurityConfigurerTemplate.BASE_NAME_FOR_AUTOGENERATED_CLASS +
                        SimpleVolatileSequencer.getSingleton().getNextValue()
        )
//        val dynamicConfigurerClass = InstrumentedClassProvider.generateRenamedClass(
//                InstrumentedWebSecurityConfigurerTemplate::class.java,
//                InstrumentedWebSecurityConfigurerTemplate::class.java.canonicalName +
//                        SimpleVolatileSequencer.getSingleton().getNextValue()
//        )

        /*
         * bean definition with supplier to provide instance of the above generated class which
         * extends WebSecurityConfigurerAdapter
         */
        val bd = BeanDefinitionBuilder.genericBeanDefinition(dynamicConfigurerClass as Class<WebSecurityConfigurerAdapter>){
            /*
             * supplier logic
             */
            val configurersFactories = listableBeanFactory.getBean(ConfigurersFactories::class.java)
            val constructor = dynamicConfigurerClass.getConstructor(ConfigurersFactories::class.java)
            constructor.newInstance(configurersFactories)
        }.beanDefinition

        /*
         * ensure the anntation properties will be injected to the bean defined by the above definition
         */
        bd.propertyValues.add("enableAnnotationAttributes", annotationAttributes)

        /*
         * register the bean definition with the bean definition registry
         */
        registry.registerBeanDefinition(
                dynamicConfigurerClass.canonicalName, bd
        )
    }

    private fun findReservedOrderNumbers(): List<Int> {
        return ReservedNumbersFinder(listableBeanFactory).findReservedNumbers()
    }

    private fun getAnnotationAttributes(importingClassMetadata: AnnotationMetadata): EnableAnnotationAttributes {

        val annotationResolver = AnnotationMetadataResolver(
                importingClassMetadata, EnableSimpleAuthenticationMethods::class
        )

        return EnableAnnotationAttributes.Builder()
                .enableAnnotationMetadata(importingClassMetadata)
                .methods(annotationResolver.getRequiredAttributeValue(
                        ENABLE_ANNOTATION_METHODS_ATTRIBUTE_NAME, Array<AuthenticationMethod>::class
                ))
                .match(annotationResolver.getRequiredAttributeValue(
                        ENABLE_ANNOTATION_MATCH_ATTRIBUTE_NAME, String::class
                ))
                .debug(annotationResolver.getRequiredAttributeValue(
                        ENABLE_ANNOTATION_DEBUG_ATTRIBUTE_NAME, Boolean::class
                ))
                .order(calculateOrderValue(annotationResolver))
                .anonymousFallback(annotationResolver.getRequiredAttributeValue(
                        ENABLE_ANNOTATION_ANONYMOUS_FALLBACK_ATTRIBUTE_NAME, Boolean::class
                ))
                .authorizations(annotationResolver.getRequiredAttributeValue(
                        ENABLE_ANNOTATION_AUTHORIZATIONS_ATTRIBUTE_NAME, String::class
                ))
                .build()
    }

    private fun calculateOrderValue(annotationResolver: AnnotationMetadataResolver):Int {
        val value = annotationResolver.getRequiredAttributeValue(
                ENABLE_ANNOTATION_ORDER_ATTRIBUTE_NAME,
                Int::class
        )
        if(value == -1) {
            return OrderingHelper.getSingleton().getNextNumber()
        } else {
            return value
        }
    }
}
